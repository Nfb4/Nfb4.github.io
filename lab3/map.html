<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
  </head>
  <body>
    <script type="text/javascript" src="https://d3js.org/d3.v7.min.js"></script>

    <style>
      #content .map path {
        stroke: #fff;
      }
      #content .centroid circle {
        fill: blue;
      }
    </style>

    <div id="content">
      <div class="info">Hover over to get details</div>
      <svg width="600" height="600">
        <g class="map"></g>
        <g class="bounding-box"><rect></rect></g>
        <g class="centroid"><circle r="4"></circle></g>
      </svg>
    </div>

    <script>
    var parseTime = d3.timeParse("%Y-%m-%d");
      // REQUEST DATA


      let owidCSV =
        "https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/owid-covid-data.csv";

      d3.csv(owidCSV).then(function (data) {
        // group the data: I want to draw one line per group
          const location = d3.group(
            data,
            (d) => d.location
          ); // nest function allows to group the calculation per level of a factor
          const ISO = d3.group(
            data,
            (d) => d.iso_code
          ); // nest function allows to group the calculation per level of a factor
        
      d3.json(
        "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson"
      ).then(function (json) {
        update(json);
      });
      const svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height");

        


      let projection = d3
        .geoMercator()
        .scale(width / 1.8 / Math.PI)
        .translate([width / 2, height / 2]);

      let geoGenerator = d3.geoPath().projection(projection);

      function handleMouseover(e, d) {
        let pixelArea = geoGenerator.area(d);
        let bounds = geoGenerator.bounds(d);
        let centroid = geoGenerator.centroid(d);
        let measure = geoGenerator.measure(d);
        console.log(d.properties.name)
        d3.select("#content .info").text(
          d.properties.name +
            " (path.area = " +
            pixelArea.toFixed(1) +
            " path.measure = " +
            measure.toFixed(1) +
            ")"
        );

        d3.select("#content .centroid")
          .style("display", "inline")
          .attr("transform", "translate(" + centroid + ")");
      }

      const color_scale = d3.scaleSqrt(["#ddd", "#777" ,"#000"]).domain(0,100000/2,100000);
      // const color_scale = d3.scaleLinear().domain(0, 100000)
      //              .range(["white", "red"]);


      function update(geojson) {
        let u = d3
          .select("#content g.map")
          .selectAll("path")
          .data(geojson.features);
        u.enter()
          .append("path")
          .attr("d", geoGenerator)
          .attr('fill', function(d){
            if(location.get(d['properties']['name']) != undefined){
                loc = location.get(d['properties']['name'])
                max = 0
                for(let i = 0; i < loc.length; i++){
                  if (loc[i].total_cases > max){max = loc[i].total_cases}
                }
                console.log(color_scale(parseInt(max)))

              return color_scale((max))
            }
            else if( ISO.get(d['properties']['name']) != undefined){
              
              loc = ISO.get(d['properties']['name'])
                max = 0
                for(let i = 0; i < loc.length; i++){
                  console.log(parseInt(max))
                  if (loc[i].total_cases > max){max = loc[i].total_cases}
                }
                console.log(color_scale(max))

              return color_scale((max))}
            else{
            return 'black';}

          })
          .on("mouseover", handleMouseover);
      }
      
        });
      
    </script>
  </body>
</html>
