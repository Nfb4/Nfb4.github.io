<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <button onclick="incomeChart('High')">High Income</button>
    <button onclick="incomeChart('mid')">Middle Income</button>
    <button onclick="incomeChart('low')">Low Income</button>
  </head>

  <body>
    <style>
      .content {
        background-color: gray;
      }
      #content .map path {
        stroke: #fff;
      }
      #content .centroid circle {
        fill: blue;
      }
      .button {
        position: relative;
      }
    </style>

    <div id="content">
      <svg width="1000" height="600">
        <g class="map"></g>
      </svg>
    </div>

    <script>
      //Define the link for the csv file
      let owidCSV =
        "https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/owid-covid-data.csv";

      //Set format so date read in can be formatted
      var parseTime = d3.timeParse("%Y-%m-%d");
      // Set margin, width and height
      var margin = { top: 20, right: 20, bottom: 50, left: 70 },
        width = 960 - margin.left - margin.right,
        height = 500 - margin.top - margin.bottom;

      // set the ranges
      var x = d3.scaleTime().range([0, width]);
      var y = d3.scaleLinear().range([height, 0]);

      // define the cases line, with date and new cases
      var valueline = d3
        .line()
        .x(function (d) {
          return x(d.date);
        })
        .y(function (d) {
          return y(d.new_cases);
        });

      // define the vaccinations line, with date and new vaccinations
      var valueline2 = d3
        .line()
        .x(function (d) {
          return x(d.date);
        })
        .y(function (d) {
          return y(d.new_vaccinations);
        });

      // append the svg obgect to the body of the page
      // appends a 'group' element to 'svg'
      // moves the 'group' element to the top left margin
      var svg = d3
        .select("body")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      // Linechart function, read in potetial country and array, if loading from gdp chart
      function lineChart(input, array) {
        d3.csv(owidCSV).then(function (data) {
          // format the data
          // If the array is undefined we load data from the url

          if (array == undefined) {
            arr = [];
            // loop through csv, if the location matches the read in loaction push the entry
            data.forEach(function (d) {
              if (d.location == input) {
                arr.push(d);
              }
            });
            // Loop through the filled array and format the values so they can be presented in the graph
            arr.forEach(function (d) {
              d.date = parseTime(d.date);
              d.new_cases = +d.new_cases;
              d.new_vaccinations = +d.new_vaccinations;
            });
          } else {
            // If the array is defined, set arr to be the array for the graph
            arr = array;
          }

          // Scale the range of the data
          // Use the min and max dates, and 0 to the largest new_vaccs numbers
          // We use new_vaccs as the value will be larger than the number of cases
          x.domain(
            d3.extent(arr, function (d) {
              return d.date;
            })
          );
          y.domain([
            0,
            d3.max(arr, function (d) {
              return d.new_vaccinations;
            }),
          ]);

          // Text labels for the 1st and booster jabs,
          // dates taken
          svg.selectAll("text").remove();
          
          var label = svg
            .append("text")
            .attr("y", 10) //magic number here so it looks nice
            .attr("x", width/2)
            .attr("text-anchor", "middle")
            .attr("class", "myLabel") //easy to style with CSS
            .text("Daily cases and Daily vaccinations");

          var first = svg
            .append("text")
            .attr("y", height - 10) //magic number here so it looks nice
            .attr("x", function () {
              return x(parseTime("2020-12-8"));
            })
            .attr("text-anchor", "middle")
            .attr("class", "myLabel") //easy to style with CSS
            .text("1st Dose");

          var third = svg
            .append("text")
            .attr("y", height - 10) //magic number here so it looks nice
            .attr("x", function () {
              return x(parseTime("2021-8-16"));
            })
            .attr("text-anchor", "middle")
            .attr("class", "myLabel") //easy to style with CSS
            .text("Booster");

          // Add the valueline path.
          // Remove the previous paths
          svg.selectAll("path").remove();
          // Create u with the array as the data set, so we can group line paths
          var u = svg.selectAll("path").data([arr]);
          // If the array is undefined we have read from the csv file, and will have a cases line and a
          // vaccines line
          if (array == undefined) {
            u.join("path")
              .attr("class", "line")
              .transition()
              .duration(3000)
              .attr("d", valueline)
              .attr("stroke", "steelblue")
              .attr("fill", "none");
          }

          // Add the path for the number of vaccines administered
          u.join("path")
            .attr("class", "line")
            .attr("fill", "none")
            .attr("stroke", "maroon")
            .transition()
            .duration(3000)
            .attr("d", valueline2);

          // Add the y Axis
          var yAxis = d3.axisLeft(y);
          svg.selectAll(".yAxis").remove();
          svg
            .append("g")
            .attr("class", "yAxis")
            .call(yAxis)
            .transition()
            .duration(3000);

          // add the xAxis
          var xAxis = d3.axisBottom(x);
          svg.selectAll(".xAxis").remove();
          svg
            .append("g")
            .attr("class", "xAxis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis)
            .transition()
            .ease(d3.easeLinear)
            .duration(3000);
        });
      }

      d3.csv(owidCSV).then(function (data) {
        // group the data: I want to draw one line per group
        const location = d3.group(data, (d) => d.location); // nest function allows to group the calculation per level of a factor
        const ISO = d3.group(data, (d) => d.iso_code); // nest function allows to group the calculation per level of a factor

        // Loop through the csv file for geoJson data for the world map
        d3.json(
          "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson"
        ).then(function (json) {
          update(json);
        });

        // Create a projection,  scale half way on between height and width so its sits readibly
        // scale down so that each country is visibile and sized somewhat similar to a general map
        let projection = d3
          .geoMercator()
          .scale(width / 2.3 / Math.PI)
          .translate([width / 2, height]);

        // Create a geopath from the projection
        let geoGenerator = d3.geoPath().projection(projection);

        // Colour scale to colour the countries based on their case values
        var scaleColor = d3
          .scaleQuantize()
          .domain([0, 250000]) // 250000 so that the colour scale is readable on the graph
          .range([
            "#f7fbff",
            "#f6faff",
            "#f5fafe",
            "#f5f9fe",
            "#f4f9fe",
            "#f3f8fe",
            "#f2f8fd",
            "#f2f7fd",
            "#f1f7fd",
            "#f0f6fd",
            "#eff6fc",
            "#eef5fc",
            "#eef5fc",
            "#edf4fc",
            "#ecf4fb",
            "#ebf3fb",
            "#eaf3fb",
            "#eaf2fb",
            "#e9f2fa",
            "#e8f1fa",
            "#e7f1fa",
            "#e7f0fa",
            "#e6f0f9",
            "#e5eff9",
            "#e4eff9",
            "#e3eef9",
            "#e3eef8",
            "#e2edf8",
            "#e1edf8",
            "#e0ecf8",
            "#e0ecf7",
            "#dfebf7",
            "#deebf7",
            "#ddeaf7",
            "#ddeaf6",
            "#dce9f6",
            "#dbe9f6",
            "#dae8f6",
            "#d9e8f5",
            "#d9e7f5",
            "#d8e7f5",
            "#d7e6f5",
            "#d6e6f4",
            "#d6e5f4",
            "#d5e5f4",
            "#d4e4f4",
            "#d3e4f3",
            "#d2e3f3",
            "#d2e3f3",
            "#d1e2f3",
            "#d0e2f2",
            "#cfe1f2",
            "#cee1f2",
            "#cde0f1",
            "#cce0f1",
            "#ccdff1",
            "#cbdff1",
            "#cadef0",
            "#c9def0",
            "#c8ddf0",
            "#c7ddef",
            "#c6dcef",
            "#c5dcef",
            "#c4dbee",
            "#c3dbee",
            "#c2daee",
            "#c1daed",
            "#c0d9ed",
            "#bfd9ec",
            "#bed8ec",
            "#bdd8ec",
            "#bcd7eb",
            "#bbd7eb",
            "#b9d6eb",
            "#b8d5ea",
            "#b7d5ea",
            "#b6d4e9",
            "#b5d4e9",
            "#b4d3e9",
            "#b2d3e8",
            "#b1d2e8",
            "#b0d1e7",
            "#afd1e7",
            "#add0e7",
            "#acd0e6",
            "#abcfe6",
            "#a9cfe5",
            "#a8cee5",
            "#a7cde5",
            "#a5cde4",
            "#a4cce4",
            "#a3cbe3",
            "#a1cbe3",
            "#a0cae3",
            "#9ec9e2",
            "#9dc9e2",
            "#9cc8e1",
            "#9ac7e1",
            "#99c6e1",
            "#97c6e0",
            "#96c5e0",
            "#94c4df",
            "#93c3df",
            "#91c3df",
            "#90c2de",
            "#8ec1de",
            "#8dc0de",
            "#8bc0dd",
            "#8abfdd",
            "#88bedc",
            "#87bddc",
            "#85bcdc",
            "#84bbdb",
            "#82bbdb",
            "#81badb",
            "#7fb9da",
            "#7eb8da",
            "#7cb7d9",
            "#7bb6d9",
            "#79b5d9",
            "#78b5d8",
            "#76b4d8",
            "#75b3d7",
            "#73b2d7",
            "#72b1d7",
            "#70b0d6",
            "#6fafd6",
            "#6daed5",
            "#6caed5",
            "#6badd5",
            "#69acd4",
            "#68abd4",
            "#66aad3",
            "#65a9d3",
            "#63a8d2",
            "#62a7d2",
            "#61a7d1",
            "#5fa6d1",
            "#5ea5d0",
            "#5da4d0",
            "#5ba3d0",
            "#5aa2cf",
            "#59a1cf",
            "#57a0ce",
            "#569fce",
            "#559ecd",
            "#549ecd",
            "#529dcc",
            "#519ccc",
            "#509bcb",
            "#4f9acb",
            "#4d99ca",
            "#4c98ca",
            "#4b97c9",
            "#4a96c9",
            "#4895c8",
            "#4794c8",
            "#4693c7",
            "#4592c7",
            "#4492c6",
            "#4391c6",
            "#4190c5",
            "#408fc4",
            "#3f8ec4",
            "#3e8dc3",
            "#3d8cc3",
            "#3c8bc2",
            "#3b8ac2",
            "#3a89c1",
            "#3988c1",
            "#3787c0",
            "#3686c0",
            "#3585bf",
            "#3484bf",
            "#3383be",
            "#3282bd",
            "#3181bd",
            "#3080bc",
            "#2f7fbc",
            "#2e7ebb",
            "#2d7dbb",
            "#2c7cba",
            "#2b7bb9",
            "#2a7ab9",
            "#2979b8",
            "#2878b8",
            "#2777b7",
            "#2676b6",
            "#2574b6",
            "#2473b5",
            "#2372b4",
            "#2371b4",
            "#2270b3",
            "#216fb3",
            "#206eb2",
            "#1f6db1",
            "#1e6cb0",
            "#1d6bb0",
            "#1c6aaf",
            "#1c69ae",
            "#1b68ae",
            "#1a67ad",
            "#1966ac",
            "#1865ab",
            "#1864aa",
            "#1763aa",
            "#1662a9",
            "#1561a8",
            "#1560a7",
            "#145fa6",
            "#135ea5",
            "#135da4",
            "#125ca4",
            "#115ba3",
            "#115aa2",
            "#1059a1",
            "#1058a0",
            "#0f579f",
            "#0e569e",
            "#0e559d",
            "#0e549c",
            "#0d539a",
            "#0d5299",
            "#0c5198",
            "#0c5097",
            "#0b4f96",
            "#0b4e95",
            "#0b4d93",
            "#0b4c92",
            "#0a4b91",
            "#0a4a90",
            "#0a498e",
            "#0a488d",
            "#09478c",
            "#09468a",
            "#094589",
            "#094487",
            "#094386",
            "#094285",
            "#094183",
            "#084082",
            "#083e80",
            "#083d7f",
            "#083c7d",
            "#083b7c",
            "#083a7a",
            "#083979",
            "#083877",
            "#083776",
            "#083674",
            "#083573",
            "#083471",
            "#083370",
            "#08326e",
            "#08316d",
            "#08306b",
          ]);

        function update(geojson) {
          // Create and append paths for each item in the geoJson dataset, using the geoGenerator to process the data
          let u = d3
            .select("#content g.map")
            .selectAll("path")
            .data(geojson.features);
          u.enter()
            .append("path")
            .attr("d", geoGenerator)
            .attr("fill", function (d) {
              // If the country matches 1:1 between data sets, the set the colour for the country
              if (location.get(d["properties"]["name"]) != undefined) {
                max = findMax(location.get(d["properties"]["name"]));

                return scaleColor(max);
                // ISO Swtich case for the USA
              } else if (ISO.get(d["properties"]["name"]) != undefined) {
                max = findMax(ISO.get(d["properties"]["name"]));

                return scaleColor(max);
              } else {
                // set the colour for the country, by calling max and inserting into the scale function
                // Switch cases set for those that do not match 1:1 between data sets
                if (d["properties"]["name"] == "England") {
                  max = findMax(location.get("United Kingdom"));

                  return scaleColor(max);
                } else if (d["properties"]["name"] == "Czech Republic") {
                  max = findMax(location.get("Czechia"));
                  return scaleColor(max);
                } else if (d["properties"]["name"] == "Republic of Serbia") {
                  max = findMax(location.get("Serbia"));
                  return scaleColor(max);
                } else if (d["properties"]["name"] == "The Bahamas") {
                  max = findMax(location.get("Bahamas"));
                  return scaleColor(max);
                } else if (d["properties"]["name"] == "Ivory Coast") {
                  max = findMax(ISO.get("CIV"));
                  return scaleColor(max);
                } else if (
                  d["properties"]["name"] == "Democratic Republic of the Congo"
                ) {
                  max = findMax(location.get("Congo"));
                  return scaleColor(max);
                } else if (d["properties"]["name"] == "Guinea Bissau") {
                  max = findMax(location.get("Guinea"));
                  return scaleColor(max);
                } else if (d["properties"]["name"] == "Puerto Rico") {
                  max = findMax(ISO.get("USA"));
                  return scaleColor(max);
                } else if (d["properties"]["name"] == "East Timor") {
                  max = findMax(location.get("Timor"));
                  return scaleColor(max);
                } else if (
                  d["properties"]["name"] == "United Republic of Tanzania"
                ) {
                  max = findMax(location.get("Tanzania"));
                  return scaleColor(max);
                }
              }
            })
            .on("click", handleMouseclick);
        }
        function handleMouseclick(e, d) {
          // On click create a linechart for the country
          // Switch cases set for those that do not match 1:1 between data sets
          if (d["properties"]["name"] == "England") {
            lineChart("United Kingdom");
          } else if (d["properties"]["name"] == "USA") {
            lineChart("United States");
          } else if (d["properties"]["name"] == "Czech Republic") {
            lineChart("Czechia");
          } else if (d["properties"]["name"] == "Republic of Serbia") {
            lineChart("Serbia");
          } else if (d["properties"]["name"] == "The Bahamas") {
            lineChart("Bahamas");
          } else if (d["properties"]["name"] == "Ivory Coast") {
            lineChart("CIV");
          } else if (
            d["properties"]["name"] == "Democratic Republic of the Congo"
          ) {
            lineChart("Congo");
          } else if (d["properties"]["name"] == "Guinea Bissau") {
            lineChart("Guinea");
          } else if (d["properties"]["name"] == "Puerto Rico") {
            lineChart("USA");
          } else if (d["properties"]["name"] == "East Timor") {
            lineChart("Timor");
          } else if (d["properties"]["name"] == "United Republic of Tanzania") {
            lineChart("Tanzania");
          } else {
            // If the country matches 1:1 between data sets, create the linechart
            lineChart(d.properties.name);
          }
        }
        //Find the highest case values for a country, to then use in the colour scale
        function findMax(loc) {
          let max = 0;
          for (let i = 0; i < loc.length; i++) {
            if (parseInt(loc[i].new_cases) > max) {
              max = parseInt(loc[i].new_cases);
            }
          }
          return max;
        }
      });
      // append the svg obgect to the body of the page
      // appends a 'group' element to 'svg'
      // moves the 'group' element to the top left margin
      var svg2 = d3
        .select("body")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      // Define a line for number of cases on the y axis and the date on the x axis
      var incomeLine = d3
        .line()
        .x(function (d) {
          return x(d.date);
        })
        .y(function (d) {
          return y(d.new_cases);
        });

      // Income chart function, read in a range ranges can be
      // "High", "mid", "low"
      // The countries in the dataset are split into three arrays based on their gdp per capita
      // this is then used to present the number of cases for these groups
      function incomeChart(range) {
        d3.csv(
          "https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/owid-covid-data.csv"
        ).then(function (data) {
          // format the data
          // Create an array to add the filtered data to
          Income = [];

          // Find the maximum gdp value in the dataset, so we can categorise countries
          max = d3.max(data, (d) => d.gdp_per_capita);

          // The data will be split based on thirds
          lowThird = max * (1 / 3);
          midThird = max * (2 / 3);

          // If the desired range is low, then countries
          // with gdp per capita lower than the lowThird will be added to the income array
          // If the desired range is mid, then countries
          // with gdp per capita lower than the midThird and higher than the lowThird
          // will be added to the income array
          // Otherwise then the data for the remaining third will be added to the income array
          data.forEach(function (d) {
            if (range == "low") {
              if (d.gdp_per_capita < lowThird) {
                Income.push(d);
              }
            } else if (range == "mid") {
              if (d.gdp_per_capita < midThird) {
                Income.push(d);
              }
            } else if (d.gdp_per_capita > midThird) {
              Income.push(d);
            }
          });
          // Loop through the array function, parse the date values, and format the number of cases and vaccine numbers
          // We format the vaccine values so the array can be passed to the linechart
          Income.forEach(function (d) {
            d.date = parseTime(d.date);
            d.new_cases = +d.new_cases;
            d.new_vaccinations = +d.new_vaccinations;
          });

          // Scale the range of the data
          // domain based on dates and cases in the income array
          x.domain(
            d3.extent(Income, function (d) {
              return d.date;
            })
          );
          y.domain([
            0,
            d3.max(Income, function (d) {
              return d.new_cases;
            }),
          ]);


          // The dates need to be sorted to merge the various countries data into one line
          Income.sort(function (a, b) {
            return new Date(b.date) - new Date(a.date);
          });

          // Append a path based on the income array
          // Remove the previous paths
          svg2.selectAll("path").remove();
          // Create u with the array as the data set, so we can group line paths
          var h = svg2.selectAll("path").data([Income]);

          // Add a path, add a on click function to load a linechart for this grouped data
          h.join("path")
            .attr("class", "line")
            .attr("stroke", "steelblue")
            .attr("fill", "none")
            .on("click", handleMouseclick)
            .transition()
            .duration(3000)
            .attr("d", incomeLine);

          function handleMouseclick() {
            lineChart("Income", Income);
          }

          // Add the y Axis
          var yAxis = d3.axisLeft(y);
          svg2.selectAll(".yAxis").remove();
          svg2
            .append("g")
            .attr("class", "yAxis")
            .call(yAxis)
            .transition()
            .duration(3000);

          // Add the xAxis
          var xAxis = d3.axisBottom(x);
          svg2.selectAll(".xAxis").remove();
          svg2
            .append("g")
            .attr("class", "xAxis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis)
            .transition()
            .ease(d3.easeLinear)
            .duration(3000);
        });
      }
      // Start by initilising to the UK
      lineChart("United Kingdom");
      incomeChart("mid");
    </script>
  </body>
</html>
