<html lang="en">
  <head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
  </head>

  <body>
    <script>
      let spend =
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/spend.csv";

      let csvArr = [
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem10-11.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem11-12.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem12-13.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem13-14.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem14-15.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem15-16.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem16-17.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem17-18.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem18-19.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem19-20.csv",
        "https://raw.githubusercontent.com/Nfb4/Nfb4.github.io/main/lab4/csvs/seasons/prem20-21.csv",
      ];

      cumulative = {};

      seasons = {
        "20-21": {},
        "19-20": {},
        "18-19": {},
        "17-18": {},
        "16-17": {},
        "15-16": {},
        "14-15": {},
        "13-14": {},
        "12-13": {},
        "11-12": {},
        "10-11": {},
      };

      let processData = function (csvArr) {
        for (let i = 0; i < csvArr.length; i++) {
          d3.csv(csvArr[i]).then(function (data) {
            let key = csvArr[i].slice(81, 86);
            if (
              seasons[csvArr[i].slice(81, 86)][data[i]["Squad"]] != undefined
            ) {
              seasons[csvArr[i].slice(81, 86)][data[i]["Squad"]] = [
                seasons[csvArr[i].slice(81, 86)][data[i]["Squad"]][0],
                seasons[csvArr[i].slice(81, 86)][data[i]["Squad"]][1],
                seasons[csvArr[i].slice(81, 86)][data[i]["Squad"]][2],
                data[i]["Rk"],
                data[i]["W"],
                data[i]["D"],
                data[i]["L"],
                data[i]["GF"],
                data[i]["GA"],
                data[i]["Pts"],
              ];
            }
          });
        }
      };

      function iniData(spendCSV) {
        d3.csv(spendCSV).then(function (data) {
          for (let i = 0; i < data.length; i++) {
            if (data[i].spend.slice(data[i].spend.length - 3) == "Th.") {
              spend =
                parseInt(data[i].spend.slice(1, data[i].spend.length - 3)) *
                0.001;
            } else if (data[i].spend == "") {
              spend = 0;
            } else {
              spend = parseInt(
                data[i].spend.slice(1, data[i].spend.length - 1)
              );
            }
            if (data[i].inc.slice(data[i].inc.length - 3) == "Th.") {
              inc =
                parseInt(data[i].inc.slice(1, data[i].inc.length - 3)) * 0.001;
            } else if (data[i].inc == "") {
              inc = 0;
            } else {
              inc = parseInt(data[i].inc.slice(1, data[i].inc.length - 1));
            }
            if (data[i].net.slice(data[i].net.length - 3) == "Th.") {
              net =
                parseInt(data[i].net.slice(1, data[i].net.length - 3)) * 0.001;
            } else if (data[i].net == "") {
              net = 0;
            } else {
              net = parseInt(data[i].net.slice(1, data[i].net.length - 1));
            }
            seasons[data[i].yr][data[i].team] = [spend, inc, net];

            if (cumulative[data[i].team] != undefined) {
              cumulative[data[i].team] = [
                cumulative[data[i].team][0] + spend,
                cumulative[data[i].team][1] + inc,
                cumulative[data[i].team][0] +
                  spend -
                  (cumulative[data[i].team][1] + inc),
              ];
            } else {
              cumulative[data[i].team] = [spend, inc, net];
            }
          }
        });
      }

      async function call() {
        try {
          await iniData(spend);
          await processData(csvArr);
        } catch (err) {
          console.log(err);
        }
      }

      // processData(csvArr, spend)
      call();

      // set the dimensions and margins of the graph
      const margin = { top: 30, right: 30, bottom: 70, left: 60 };
      const width = 460 - margin.left - margin.right;
      const height = 400 - margin.top - margin.bottom;

      // append the svg object to the body of the page
      var svg = d3
        .select("body")
        .append("div")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      // Function used to initilise the x and y axes on start
      function iniAxis(x, y) {
        // add a bottom x axis to the graph, class it as 'xBot'
        svg
          .append("g")
          .classed("xBot", true)
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x));

        // add a top x axis to the graph, class it as 'xTop'
        svg
          .append("g")
          .classed("xTop", true)
          .attr("transform", "translate(0,0")
          .call(d3.axisTop(x));

        // Add a right Y axis class it as 'yRight'
        svg
          .append("g")
          .classed("yRight", true)
          .attr("transform", "translate(" + width + ",0)")
          .call(d3.axisRight(y));

        // Add a right Y axis class it as 'yLeft'
        svg
          .append("g")
          .classed("yLeft", true)
          .attr("class", "myYaxis")
          .call(d3.axisLeft(y));
      }

      // A function that create / update the plot for a given variable
      // also updates the axes as the size of the dataset changes
      function update(data) {
        // Defining x scale so values are proportionate
        const keys = Object.keys(data);



        console.log((data))
        var max = d3.max(data, function(d) {
          console.log
          return d[1];

        })
        console.log(max)



        // colour = red
        // var x = d3
        //   .scaleBand()
        //   .range([0, width])
        //   .domain(
        //     data.map(function (d) {
        //       return d.group;
        //     })
        //   )
        //   .padding(0.2);

        // // Define the y scale so that the values are proportionate
        // var y = d3.scaleLinear().domain([0, d3.max(data[2])]).range([height, 0]);

        // // Intilise the axes
        // iniAxis(x, y);

 
      }

      update(seasons['20-21'])
    </script>
  </body>
</html>
